using System;
using System.Collections.Generic;

using System.Globalization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;

// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//
//    var function = Function.FromJson(jsonString);

namespace ElementsCADUI.Models
{

    /// <summary>
    /// The Hypar function schema.
    /// </summary>
    public partial class FunctionDefinition
    {
        [JsonProperty("$schema", NullValueHandling = NullValueHandling.Ignore)]
        public string Schema { get; set; }

        /// <summary>
        /// The preferred camera for viewing geometry produced by this function.
        /// </summary>
        [JsonProperty("default_camera", NullValueHandling = NullValueHandling.Ignore)]
        public Camera DefaultCamera { get; set; }

        /// <summary>
        /// A description of the function.
        /// </summary>
        [JsonProperty("description")]
        public string Description { get; set; }

        /// <summary>
        /// An optional display name for this function (useful if you want to change the function's
        /// name without changing code)
        /// </summary>
        [JsonProperty("display_name", NullValueHandling = NullValueHandling.Ignore)]
        public string DisplayName { get; set; }

        /// <summary>
        /// An array of uris representing element type JSON schemas.
        /// </summary>
        [JsonProperty("element_types", NullValueHandling = NullValueHandling.Ignore)]
        public string[] ElementTypes { get; set; }

        [JsonProperty("filters", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, object> Filters { get; set; }

        /// <summary>
        /// An identifier for the function which must be unique within the system. Function ids can
        /// contain any lowercase alphanumeric character, '_', and '-'.
        /// </summary>
        [JsonProperty("id")]
        public string Id { get; set; }

        [JsonProperty("input_schema", NullValueHandling = NullValueHandling.Ignore)]
        public InputSchema InputSchema { get; set; }

        /// <summary>
        /// An array of inputs to the function.
        /// </summary>
        [JsonProperty("inputs", NullValueHandling = NullValueHandling.Ignore)]
        public InputElement[] Inputs { get; set; }

        /// <summary>
        /// The programming language used by this function.
        /// </summary>
        [JsonProperty("language", NullValueHandling = NullValueHandling.Ignore)]
        public Language? Language { get; set; }

        /// <summary>
        /// A mapping from language codes to visible text in that language.
        /// </summary>
        [JsonProperty("messages", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, object> Messages { get; set; }

        /// <summary>
        /// An array of model types that this function consumes.
        /// </summary>
        [JsonProperty("model_dependencies", NullValueHandling = NullValueHandling.Ignore)]
        public ModelDependencyElement[] ModelDependencies { get; set; }

        /// <summary>
        /// The model type produced by this function.
        /// </summary>
        [JsonProperty("model_output", NullValueHandling = NullValueHandling.Ignore)]
        public string ModelOutput { get; set; }

        /// <summary>
        /// A human readable name.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }

        /// <summary>
        /// The outputs of the function.
        /// </summary>
        [JsonProperty("outputs", NullValueHandling = NullValueHandling.Ignore)]
        public Output[] Outputs { get; set; }

        [JsonProperty("overrides", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, object> Overrides { get; set; }

        /// <summary>
        /// A base64 encoded .png containing a preview image.
        /// </summary>
        [JsonProperty("preview_image")]
        public string PreviewImage { get; set; }

        /// <summary>
        /// The url of the git repository that contains the code for this function.
        /// </summary>
        [JsonProperty("repository_url", NullValueHandling = NullValueHandling.Ignore)]
        public string RepositoryUrl { get; set; }

        /// <summary>
        /// The S3 key used to retrieve a source file needed for execution.
        /// </summary>
        [JsonProperty("source_file_key")]
        public string SourceFileKey { get; set; }
    }

    /// <summary>
    /// The preferred camera for viewing geometry produced by this function.
    /// </summary>
    public partial class Camera
    {
        /// <summary>
        /// A unit vector in model coordinates indicating which direction the camera is pointing.
        /// </summary>
        [JsonProperty("angle", NullValueHandling = NullValueHandling.Ignore)]
        public double[] Angle { get; set; }

        /// <summary>
        /// Camera positions, viewing from this direction to the opposite direction. Do not set angle
        /// if setting this.
        /// </summary>
        [JsonProperty("named_position", NullValueHandling = NullValueHandling.Ignore)]
        public NamedPosition? NamedPosition { get; set; }

        /// <summary>
        /// How the camera collapses the 3d scene into a 2d image
        /// </summary>
        [JsonProperty("projection", NullValueHandling = NullValueHandling.Ignore)]
        public Projection? Projection { get; set; }
    }

    public partial class InputSchema
    {
        [JsonProperty("properties")]
        public Dictionary<string, HyparFunctionInputSchemaMetaSchemaValue> Properties { get; set; }

        [JsonProperty("type")]
        public InputSchemaType Type { get; set; }
    }

    public partial class HyparFunctionInputSchemaMetaSchemaValue
    {
        [JsonProperty("$comment", NullValueHandling = NullValueHandling.Ignore)]
        public string Comment { get; set; }

        [JsonProperty("$hyparAdditionalPropertiesQuery", NullValueHandling = NullValueHandling.Ignore)]
        public Query HyparAdditionalPropertiesQuery { get; set; }

        [JsonProperty("$hyparAutocomplete", NullValueHandling = NullValueHandling.Ignore)]
        public string[] HyparAutocomplete { get; set; }

        /// <summary>
        /// If true, this input will have a button to permit popping it out into a separate window or
        /// widget.
        /// </summary>
        [JsonProperty("$hyparCanPopOut", NullValueHandling = NullValueHandling.Ignore)]
        public bool? HyparCanPopOut { get; set; }

        [JsonProperty("$hyparConditionalControl", NullValueHandling = NullValueHandling.Ignore)]
        public PurpleHyparConditionalControl HyparConditionalControl { get; set; }

        /// <summary>
        /// Deprecate this input
        /// </summary>
        [JsonProperty("$hyparDeprecated", NullValueHandling = NullValueHandling.Ignore)]
        public bool? HyparDeprecated { get; set; }

        /// <summary>
        /// Turn on this flag to disable 'Sample Range' on an input.
        /// </summary>
        [JsonProperty("$hyparDisableRange", NullValueHandling = NullValueHandling.Ignore)]
        public bool? HyparDisableRange { get; set; }

        /// <summary>
        /// Set the visible name of an input without changing how it is represented in internal data.
        /// </summary>
        [JsonProperty("$hyparDisplayName", NullValueHandling = NullValueHandling.Ignore)]
        public string HyparDisplayName { get; set; }

        [JsonProperty("$hyparEnumQuery", NullValueHandling = NullValueHandling.Ignore)]
        public Query HyparEnumQuery { get; set; }

        [JsonProperty("$hyparHidden", NullValueHandling = NullValueHandling.Ignore)]
        public string[] HyparHidden { get; set; }

        /// <summary>
        /// Utilize this property to lock the default value of an input.
        /// </summary>
        [JsonProperty("$hyparLock", NullValueHandling = NullValueHandling.Ignore)]
        public HyparLock? HyparLock { get; set; }

        /// <summary>
        /// This value sets the order of this input in display. Usually it is unnecessary to set this
        /// explicitly, it will be added when you publish.
        /// </summary>
        [JsonProperty("$hyparOrder", NullValueHandling = NullValueHandling.Ignore)]
        public double? HyparOrder { get; set; }

        /// <summary>
        /// Make the display of this property conditional on the value of another property.
        /// </summary>
        [JsonProperty("$hyparShowIf", NullValueHandling = NullValueHandling.Ignore)]
        public FluffyHyparShowIf HyparShowIf { get; set; }

        [JsonProperty("$hyparStyle", NullValueHandling = NullValueHandling.Ignore)]
        public HyparStyle? HyparStyle { get; set; }

        [JsonProperty("$hyparValueQuery", NullValueHandling = NullValueHandling.Ignore)]
        public ValueQuery HyparValueQuery { get; set; }

        [JsonProperty("$id", NullValueHandling = NullValueHandling.Ignore)]
        public string Id { get; set; }

        [JsonProperty("$ref", NullValueHandling = NullValueHandling.Ignore)]
        public string Ref { get; set; }

        [JsonProperty("$schema", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Schema { get; set; }

        [JsonProperty("additionalItems", NullValueHandling = NullValueHandling.Ignore)]
        public HyparFunctionInputSchemaMetaSchemaElement AdditionalItems { get; set; }

        [JsonProperty("additionalProperties", NullValueHandling = NullValueHandling.Ignore)]
        public HyparFunctionInputSchemaMetaSchemaElement AdditionalProperties { get; set; }

        [JsonProperty("allOf", NullValueHandling = NullValueHandling.Ignore)]
        public HyparFunctionInputSchemaMetaSchemaElement[] AllOf { get; set; }

        [JsonProperty("anyOf", NullValueHandling = NullValueHandling.Ignore)]
        public HyparFunctionInputSchemaMetaSchemaElement[] AnyOf { get; set; }

        [JsonProperty("const")]
        public object Const { get; set; }

        [JsonProperty("contains", NullValueHandling = NullValueHandling.Ignore)]
        public HyparFunctionInputSchemaMetaSchemaElement Contains { get; set; }

        [JsonProperty("contentEncoding", NullValueHandling = NullValueHandling.Ignore)]
        public string ContentEncoding { get; set; }

        [JsonProperty("contentMediaType", NullValueHandling = NullValueHandling.Ignore)]
        public string ContentMediaType { get; set; }

        [JsonProperty("default")]
        public object Default { get; set; }

        [JsonProperty("definitions", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, HyparFunctionInputSchemaMetaSchemaElement> Definitions { get; set; }

        [JsonProperty("dependencies", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, DependencyValue> Dependencies { get; set; }

        [JsonProperty("description", NullValueHandling = NullValueHandling.Ignore)]
        public string Description { get; set; }

        [JsonProperty("else", NullValueHandling = NullValueHandling.Ignore)]
        public HyparFunctionInputSchemaMetaSchemaElement Else { get; set; }

        [JsonProperty("enum", NullValueHandling = NullValueHandling.Ignore)]
        public double[] Enum { get; set; }

        [JsonProperty("examples", NullValueHandling = NullValueHandling.Ignore)]
        public bool[] Examples { get; set; }

        [JsonProperty("exclusiveMaximum", NullValueHandling = NullValueHandling.Ignore)]
        public double? ExclusiveMaximum { get; set; }

        [JsonProperty("exclusiveMinimum", NullValueHandling = NullValueHandling.Ignore)]
        public double? ExclusiveMinimum { get; set; }

        [JsonProperty("format", NullValueHandling = NullValueHandling.Ignore)]
        public string Format { get; set; }

        [JsonProperty("if", NullValueHandling = NullValueHandling.Ignore)]
        public HyparFunctionInputSchemaMetaSchemaElement If { get; set; }

        [JsonProperty("items", NullValueHandling = NullValueHandling.Ignore)]
        public Items? Items { get; set; }

        [JsonProperty("maximum", NullValueHandling = NullValueHandling.Ignore)]
        public double? Maximum { get; set; }

        [JsonProperty("maxItems", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxItems { get; set; }

        [JsonProperty("maxLength", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxLength { get; set; }

        [JsonProperty("maxProperties", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxProperties { get; set; }

        [JsonProperty("minimum", NullValueHandling = NullValueHandling.Ignore)]
        public double? Minimum { get; set; }

        [JsonProperty("minItems", NullValueHandling = NullValueHandling.Ignore)]
        public long? MinItems { get; set; }

        [JsonProperty("minLength", NullValueHandling = NullValueHandling.Ignore)]
        public long? MinLength { get; set; }

        [JsonProperty("minProperties", NullValueHandling = NullValueHandling.Ignore)]
        public long? MinProperties { get; set; }

        [JsonProperty("multipleOf", NullValueHandling = NullValueHandling.Ignore)]
        public double? MultipleOf { get; set; }

        [JsonProperty("not", NullValueHandling = NullValueHandling.Ignore)]
        public HyparFunctionInputSchemaMetaSchemaElement Not { get; set; }

        [JsonProperty("oneOf", NullValueHandling = NullValueHandling.Ignore)]
        public HyparFunctionInputSchemaMetaSchemaElement[] OneOf { get; set; }

        [JsonProperty("pattern", NullValueHandling = NullValueHandling.Ignore)]
        public string Pattern { get; set; }

        [JsonProperty("patternProperties", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, HyparFunctionInputSchemaMetaSchemaElement> PatternProperties { get; set; }

        [JsonProperty("properties", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, HyparFunctionInputSchemaMetaSchemaElement> Properties { get; set; }

        [JsonProperty("propertyNames", NullValueHandling = NullValueHandling.Ignore)]
        public HyparFunctionInputSchemaMetaSchemaElement PropertyNames { get; set; }

        [JsonProperty("readOnly", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }

        [JsonProperty("required", NullValueHandling = NullValueHandling.Ignore)]
        public string[] HyparFunctionInputSchemaMetaSchemaRequired { get; set; }

        [JsonProperty("then", NullValueHandling = NullValueHandling.Ignore)]
        public HyparFunctionInputSchemaMetaSchemaElement Then { get; set; }

        [JsonProperty("title", NullValueHandling = NullValueHandling.Ignore)]
        public string Title { get; set; }

        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public TypeUnion? Type { get; set; }

        [JsonProperty("uniqueItems", NullValueHandling = NullValueHandling.Ignore)]
        public bool? UniqueItems { get; set; }

        [JsonProperty("writeOnly", NullValueHandling = NullValueHandling.Ignore)]
        public bool? WriteOnly { get; set; }
    }

    public partial class FluffyHyparConditionalControl
    {
        [JsonProperty("conditions")]
        public ConditionsArray[] Conditions { get; set; }

        [JsonProperty("defaultControl", NullValueHandling = NullValueHandling.Ignore)]
        public HyparFunctionInputSchemaMetaSchemaElement DefaultControl { get; set; }
    }

    public partial class HyparFunctionInputSchemaMetaSchemaElement
    {
        [JsonProperty("$comment", NullValueHandling = NullValueHandling.Ignore)]
        public string Comment { get; set; }

        [JsonProperty("$hyparAdditionalPropertiesQuery", NullValueHandling = NullValueHandling.Ignore)]
        public Query HyparAdditionalPropertiesQuery { get; set; }

        [JsonProperty("$hyparAutocomplete", NullValueHandling = NullValueHandling.Ignore)]
        public string[] HyparAutocomplete { get; set; }

        /// <summary>
        /// If true, this input will have a button to permit popping it out into a separate window or
        /// widget.
        /// </summary>
        [JsonProperty("$hyparCanPopOut", NullValueHandling = NullValueHandling.Ignore)]
        public bool? HyparCanPopOut { get; set; }

        [JsonProperty("$hyparConditionalControl", NullValueHandling = NullValueHandling.Ignore)]
        public FluffyHyparConditionalControl HyparConditionalControl { get; set; }

        /// <summary>
        /// Deprecate this input
        /// </summary>
        [JsonProperty("$hyparDeprecated", NullValueHandling = NullValueHandling.Ignore)]
        public bool? HyparDeprecated { get; set; }

        /// <summary>
        /// Turn on this flag to disable 'Sample Range' on an input.
        /// </summary>
        [JsonProperty("$hyparDisableRange", NullValueHandling = NullValueHandling.Ignore)]
        public bool? HyparDisableRange { get; set; }

        /// <summary>
        /// Set the visible name of an input without changing how it is represented in internal data.
        /// </summary>
        [JsonProperty("$hyparDisplayName", NullValueHandling = NullValueHandling.Ignore)]
        public string HyparDisplayName { get; set; }

        [JsonProperty("$hyparEnumQuery", NullValueHandling = NullValueHandling.Ignore)]
        public Query HyparEnumQuery { get; set; }

        [JsonProperty("$hyparHidden", NullValueHandling = NullValueHandling.Ignore)]
        public string[] HyparHidden { get; set; }

        /// <summary>
        /// Utilize this property to lock the default value of an input.
        /// </summary>
        [JsonProperty("$hyparLock", NullValueHandling = NullValueHandling.Ignore)]
        public HyparLock? HyparLock { get; set; }

        /// <summary>
        /// This value sets the order of this input in display. Usually it is unnecessary to set this
        /// explicitly, it will be added when you publish.
        /// </summary>
        [JsonProperty("$hyparOrder", NullValueHandling = NullValueHandling.Ignore)]
        public double? HyparOrder { get; set; }

        /// <summary>
        /// Make the display of this property conditional on the value of another property.
        /// </summary>
        [JsonProperty("$hyparShowIf", NullValueHandling = NullValueHandling.Ignore)]
        public PurpleHyparShowIf HyparShowIf { get; set; }

        [JsonProperty("$hyparStyle", NullValueHandling = NullValueHandling.Ignore)]
        public HyparStyle? HyparStyle { get; set; }

        [JsonProperty("$hyparValueQuery", NullValueHandling = NullValueHandling.Ignore)]
        public ValueQuery HyparValueQuery { get; set; }

        [JsonProperty("$id", NullValueHandling = NullValueHandling.Ignore)]
        public string Id { get; set; }

        [JsonProperty("$ref", NullValueHandling = NullValueHandling.Ignore)]
        public string Ref { get; set; }

        [JsonProperty("$schema", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Schema { get; set; }

        [JsonProperty("additionalItems", NullValueHandling = NullValueHandling.Ignore)]
        public HyparFunctionInputSchemaMetaSchemaElement AdditionalItems { get; set; }

        [JsonProperty("additionalProperties", NullValueHandling = NullValueHandling.Ignore)]
        public HyparFunctionInputSchemaMetaSchemaElement AdditionalProperties { get; set; }

        [JsonProperty("allOf", NullValueHandling = NullValueHandling.Ignore)]
        public HyparFunctionInputSchemaMetaSchemaElement[] AllOf { get; set; }

        [JsonProperty("anyOf", NullValueHandling = NullValueHandling.Ignore)]
        public HyparFunctionInputSchemaMetaSchemaElement[] AnyOf { get; set; }

        [JsonProperty("const")]
        public object Const { get; set; }

        [JsonProperty("contains", NullValueHandling = NullValueHandling.Ignore)]
        public HyparFunctionInputSchemaMetaSchemaElement Contains { get; set; }

        [JsonProperty("contentEncoding", NullValueHandling = NullValueHandling.Ignore)]
        public string ContentEncoding { get; set; }

        [JsonProperty("contentMediaType", NullValueHandling = NullValueHandling.Ignore)]
        public string ContentMediaType { get; set; }

        [JsonProperty("default")]
        public object Default { get; set; }

        [JsonProperty("definitions", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, HyparFunctionInputSchemaMetaSchemaElement> Definitions { get; set; }

        [JsonProperty("dependencies", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, DependencyValue> Dependencies { get; set; }

        [JsonProperty("description", NullValueHandling = NullValueHandling.Ignore)]
        public string Description { get; set; }

        [JsonProperty("else", NullValueHandling = NullValueHandling.Ignore)]
        public HyparFunctionInputSchemaMetaSchemaElement Else { get; set; }

        [JsonProperty("enum", NullValueHandling = NullValueHandling.Ignore)]
        public double[] Enum { get; set; }

        [JsonProperty("examples", NullValueHandling = NullValueHandling.Ignore)]
        public bool[] Examples { get; set; }

        [JsonProperty("exclusiveMaximum", NullValueHandling = NullValueHandling.Ignore)]
        public double? ExclusiveMaximum { get; set; }

        [JsonProperty("exclusiveMinimum", NullValueHandling = NullValueHandling.Ignore)]
        public double? ExclusiveMinimum { get; set; }

        [JsonProperty("format", NullValueHandling = NullValueHandling.Ignore)]
        public string Format { get; set; }

        [JsonProperty("if", NullValueHandling = NullValueHandling.Ignore)]
        public HyparFunctionInputSchemaMetaSchemaElement If { get; set; }

        [JsonProperty("items", NullValueHandling = NullValueHandling.Ignore)]
        public Items? Items { get; set; }

        [JsonProperty("maximum", NullValueHandling = NullValueHandling.Ignore)]
        public double? Maximum { get; set; }

        [JsonProperty("maxItems", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxItems { get; set; }

        [JsonProperty("maxLength", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxLength { get; set; }

        [JsonProperty("maxProperties", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxProperties { get; set; }

        [JsonProperty("minimum", NullValueHandling = NullValueHandling.Ignore)]
        public double? Minimum { get; set; }

        [JsonProperty("minItems", NullValueHandling = NullValueHandling.Ignore)]
        public long? MinItems { get; set; }

        [JsonProperty("minLength", NullValueHandling = NullValueHandling.Ignore)]
        public long? MinLength { get; set; }

        [JsonProperty("minProperties", NullValueHandling = NullValueHandling.Ignore)]
        public long? MinProperties { get; set; }

        [JsonProperty("multipleOf", NullValueHandling = NullValueHandling.Ignore)]
        public double? MultipleOf { get; set; }

        [JsonProperty("not", NullValueHandling = NullValueHandling.Ignore)]
        public HyparFunctionInputSchemaMetaSchemaElement Not { get; set; }

        [JsonProperty("oneOf", NullValueHandling = NullValueHandling.Ignore)]
        public HyparFunctionInputSchemaMetaSchemaElement[] OneOf { get; set; }

        [JsonProperty("pattern", NullValueHandling = NullValueHandling.Ignore)]
        public string Pattern { get; set; }

        [JsonProperty("patternProperties", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, HyparFunctionInputSchemaMetaSchemaElement> PatternProperties { get; set; }

        [JsonProperty("properties", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, HyparFunctionInputSchemaMetaSchemaElement> Properties { get; set; }

        [JsonProperty("propertyNames", NullValueHandling = NullValueHandling.Ignore)]
        public HyparFunctionInputSchemaMetaSchemaElement PropertyNames { get; set; }

        [JsonProperty("readOnly", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }

        [JsonProperty("required", NullValueHandling = NullValueHandling.Ignore)]
        public string[] HyparFunctionInputSchemaMetaSchemaRequired { get; set; }

        [JsonProperty("then", NullValueHandling = NullValueHandling.Ignore)]
        public HyparFunctionInputSchemaMetaSchemaElement Then { get; set; }

        [JsonProperty("title", NullValueHandling = NullValueHandling.Ignore)]
        public string Title { get; set; }

        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public TypeUnion? Type { get; set; }

        [JsonProperty("uniqueItems", NullValueHandling = NullValueHandling.Ignore)]
        public bool? UniqueItems { get; set; }

        [JsonProperty("writeOnly", NullValueHandling = NullValueHandling.Ignore)]
        public bool? WriteOnly { get; set; }
    }

    public partial class ConditionsArray
    {
        [JsonProperty("property", NullValueHandling = NullValueHandling.Ignore)]
        public string Property { get; set; }

        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public ConditionType? Type { get; set; }

        [JsonProperty("value")]
        public object Value { get; set; }
    }

    public partial class Query
    {
        [JsonProperty("dependency", NullValueHandling = NullValueHandling.Ignore)]
        public string Dependency { get; set; }

        [JsonProperty("query")]
        public string QueryQuery { get; set; }

        [JsonProperty("selfDependency", NullValueHandling = NullValueHandling.Ignore)]
        public bool? SelfDependency { get; set; }
    }

    /// <summary>
    /// Make the display of this property conditional on the value of another property.
    /// </summary>
    public partial class PurpleHyparShowIf
    {
        [JsonProperty("conditions", NullValueHandling = NullValueHandling.Ignore)]
        public ConditionsArray[] Conditions { get; set; }

        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public HyparShowIfType? Type { get; set; }
    }

    public partial class ValueQuery
    {
        [JsonProperty("aggregator", NullValueHandling = NullValueHandling.Ignore)]
        public Aggregator? Aggregator { get; set; }

        [JsonProperty("dependency")]
        public string Dependency { get; set; }

        [JsonProperty("discriminator", NullValueHandling = NullValueHandling.Ignore)]
        public string Discriminator { get; set; }

        [JsonProperty("query")]
        public string Query { get; set; }
    }

    public partial class PurpleHyparConditionalControl
    {
        [JsonProperty("conditions")]
        public ConditionsArray[] Conditions { get; set; }

        [JsonProperty("defaultControl", NullValueHandling = NullValueHandling.Ignore)]
        public HyparFunctionInputSchemaMetaSchemaElement DefaultControl { get; set; }
    }

    /// <summary>
    /// Make the display of this property conditional on the value of another property.
    /// </summary>
    public partial class FluffyHyparShowIf
    {
        [JsonProperty("conditions", NullValueHandling = NullValueHandling.Ignore)]
        public ConditionsArray[] Conditions { get; set; }

        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public HyparShowIfType? Type { get; set; }
    }

    public partial class InputClass
    {
        /// <summary>
        /// The type of geometry to accept.
        /// </summary>
        [JsonProperty("primitive_type", NullValueHandling = NullValueHandling.Ignore)]
        public PrimitiveType? PrimitiveType { get; set; }

        [JsonProperty("type")]
        public InputType Type { get; set; }

        [JsonProperty("name")]
        public object Name { get; set; }

        [JsonProperty("description")]
        public object Description { get; set; }

        /// <summary>
        /// The maximum value of the range.
        /// </summary>
        [JsonProperty("max", NullValueHandling = NullValueHandling.Ignore)]
        public double? Max { get; set; }

        /// <summary>
        /// The minimum value of the range.
        /// </summary>
        [JsonProperty("min", NullValueHandling = NullValueHandling.Ignore)]
        public double? Min { get; set; }

        /// <summary>
        /// The value used to calculate intermediate values between 'min' and 'max'.
        /// </summary>
        [JsonProperty("step", NullValueHandling = NullValueHandling.Ignore)]
        public double? Step { get; set; }

        [JsonProperty("unit_type", NullValueHandling = NullValueHandling.Ignore)]
        public UnitType? UnitType { get; set; }

        [JsonProperty("item_type", NullValueHandling = NullValueHandling.Ignore)]
        public ItemType? ItemType { get; set; }

        /// <summary>
        /// An array of mapbox layer ids which contain selectable areas.
        /// </summary>
        [JsonProperty("mapbox_layer_ids", NullValueHandling = NullValueHandling.Ignore)]
        public string[] MapboxLayerIds { get; set; }

        /// <summary>
        /// The origin of the mapbox view presented for this location input.
        /// </summary>
        [JsonProperty("mapbox_origin", NullValueHandling = NullValueHandling.Ignore)]
        public double[] MapboxOrigin { get; set; }

        /// <summary>
        /// The mapbox style url. This style will be used to style the input control and the 3D
        /// context.
        /// </summary>
        [JsonProperty("mapbox_style_url", NullValueHandling = NullValueHandling.Ignore)]
        public string MapboxStyleUrl { get; set; }

        /// <summary>
        /// DEPRECATED: replaced by file_types.
        /// </summary>
        [JsonProperty("content_type", NullValueHandling = NullValueHandling.Ignore)]
        public ContentType? ContentType { get; set; }

        /// <summary>
        /// Acceptable file extensions for the data file. Examples: 'csv', 'ifc', 'json'.
        /// </summary>
        [JsonProperty("file_types", NullValueHandling = NullValueHandling.Ignore)]
        public string[] FileTypes { get; set; }

        /// <summary>
        /// The choices available to the user.
        /// </summary>
        [JsonProperty("choices", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Choices { get; set; }
    }

    public partial class ModelDependencyElement
    {
        /// <summary>
        /// Whether to hide the dependency's geometry when your function has visible geometry. Use
        /// this when your function largely replaces and elaborates on the geometry of this
        /// dependency, such that users will not need to see both at once.
        /// </summary>
        [JsonProperty("autohide", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Autohide { get; set; }

        /// <summary>
        /// The model type that this function consumes.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }

        /// <summary>
        /// Whether the function can run even if this dependency is unavailable.
        /// </summary>
        [JsonProperty("optional", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Optional { get; set; }
    }

    public partial class Output
    {
        /// <summary>
        /// A description of the output that will appear in the Hypar app.
        /// </summary>
        [JsonProperty("description")]
        public string Description { get; set; }

        /// <summary>
        /// The name of the output.
        /// </summary>
        [JsonProperty("name")]
        public string Name { get; set; }

        /// <summary>
        /// The type of the output. Only 'number' and 'string' types are currently supported.
        /// </summary>
        [JsonProperty("type")]
        public OutputType Type { get; set; }

        [JsonProperty("unit_type", NullValueHandling = NullValueHandling.Ignore)]
        public UnitType? UnitType { get; set; }
    }

    /// <summary>
    /// Camera positions, viewing from this direction to the opposite direction. Do not set angle
    /// if setting this.
    /// </summary>
    public enum NamedPosition { East, North, South, Top, West };

    /// <summary>
    /// How the camera collapses the 3d scene into a 2d image
    /// </summary>
    public enum Projection { Orthographic, Perspective };

    public enum ConditionType { DoesNotEqual, Equals };

    public enum HyparShowIfType { All, Any };

    public enum HyparStyle { Matrix, Number, Row, Standard };

    public enum Aggregator { Average, Count, CountUnique, Display, DisplayUnique, Max, Min, NonZeroAverage, None, SingleValue, Sum };

    public enum SimpleTypes { Array, Boolean, Integer, Null, Number, Object, String };

    public enum InputSchemaType { Object };

    /// <summary>
    /// DEPRECATED: replaced by file_types.
    /// </summary>
    public enum ContentType { ApplicationJson, TextCsv, TextIfc };

    public enum ItemType { Range, String };

    /// <summary>
    /// The type of geometry to accept.
    /// </summary>
    public enum PrimitiveType { Polygon, Polyline };

    public enum InputType { Boolean, Choice, Data, Geometry, List, Location, Number, Range, String };

    /// <summary>
    /// The unit type of the numeric value.
    /// </summary>
    public enum UnitType { Area, Force, Length, Mass, None, PlaneAngle, Pressure, Time, Volume };

    /// <summary>
    /// The programming language used by this function.
    /// </summary>
    public enum Language { C, Excel, Grasshopper, Python };

    /// <summary>
    /// The type of the output. Only 'number' and 'string' types are currently supported.
    /// </summary>
    public enum OutputType { Number, String };

    public partial struct Items
    {
        public HyparFunctionInputSchemaMetaSchemaElement HyparFunctionInputSchemaMetaSchemaElement;
        public HyparFunctionInputSchemaMetaSchemaElement[] HyparFunctionInputSchemaMetaSchemaElementArray;

        public static implicit operator Items(HyparFunctionInputSchemaMetaSchemaElement HyparFunctionInputSchemaMetaSchemaElement) => new Items { HyparFunctionInputSchemaMetaSchemaElement = HyparFunctionInputSchemaMetaSchemaElement };
        public static implicit operator Items(HyparFunctionInputSchemaMetaSchemaElement[] HyparFunctionInputSchemaMetaSchemaElementArray) => new Items { HyparFunctionInputSchemaMetaSchemaElementArray = HyparFunctionInputSchemaMetaSchemaElementArray };
    }

    public partial struct DependencyValue
    {
        public HyparFunctionInputSchemaMetaSchemaElement HyparFunctionInputSchemaMetaSchemaElement;
        public string[] StringArray;

        public static implicit operator DependencyValue(HyparFunctionInputSchemaMetaSchemaElement HyparFunctionInputSchemaMetaSchemaElement) => new DependencyValue { HyparFunctionInputSchemaMetaSchemaElement = HyparFunctionInputSchemaMetaSchemaElement };
        public static implicit operator DependencyValue(string[] StringArray) => new DependencyValue { StringArray = StringArray };
    }

    /// <summary>
    /// Utilize this property to lock the default value of an input.
    /// </summary>
    public partial struct HyparLock
    {
        public bool? Bool;
        public string[] StringArray;

        public static implicit operator HyparLock(bool Bool) => new HyparLock { Bool = Bool };
        public static implicit operator HyparLock(string[] StringArray) => new HyparLock { StringArray = StringArray };
    }

    public partial struct TypeUnion
    {
        public SimpleTypes? Enum;
        public SimpleTypes[] StringArray;

        public static implicit operator TypeUnion(SimpleTypes Enum) => new TypeUnion { Enum = Enum };
        public static implicit operator TypeUnion(SimpleTypes[] StringArray) => new TypeUnion { StringArray = StringArray };
    }

    public partial struct InputElement
    {
        public object[] AnythingArray;
        public bool? Bool;
        public double? Double;
        public InputClass InputClass;
        public long? Integer;
        public string String;

        public static implicit operator InputElement(object[] AnythingArray) => new InputElement { AnythingArray = AnythingArray };
        public static implicit operator InputElement(bool Bool) => new InputElement { Bool = Bool };
        public static implicit operator InputElement(double Double) => new InputElement { Double = Double };
        public static implicit operator InputElement(InputClass InputClass) => new InputElement { InputClass = InputClass };
        public static implicit operator InputElement(long Integer) => new InputElement { Integer = Integer };
        public static implicit operator InputElement(string String) => new InputElement { String = String };
        public bool IsNull => AnythingArray == null && Bool == null && InputClass == null && Double == null && Integer == null && String == null;
    }

    public partial class FunctionDefinition
    {
        public static FunctionDefinition FromJson(string json) => JsonConvert.DeserializeObject<FunctionDefinition>(json, Models.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this FunctionDefinition self) => JsonConvert.SerializeObject(self, Models.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                NamedPositionConverter.Singleton,
                ProjectionConverter.Singleton,
                ConditionTypeConverter.Singleton,
                HyparLockConverter.Singleton,
                HyparShowIfTypeConverter.Singleton,
                HyparStyleConverter.Singleton,
                AggregatorConverter.Singleton,
                DependencyValueConverter.Singleton,
                ItemsConverter.Singleton,
                TypeUnionConverter.Singleton,
                SimpleTypesConverter.Singleton,
                InputSchemaTypeConverter.Singleton,
                InputElementConverter.Singleton,
                ContentTypeConverter.Singleton,
                ItemTypeConverter.Singleton,
                PrimitiveTypeConverter.Singleton,
                InputTypeConverter.Singleton,
                UnitTypeConverter.Singleton,
                LanguageConverter.Singleton,
                OutputTypeConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class NamedPositionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(NamedPosition) || t == typeof(NamedPosition?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "east":
                    return NamedPosition.East;
                case "north":
                    return NamedPosition.North;
                case "south":
                    return NamedPosition.South;
                case "top":
                    return NamedPosition.Top;
                case "west":
                    return NamedPosition.West;
            }
            throw new Exception("Cannot unmarshal type NamedPosition");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (NamedPosition)untypedValue;
            switch (value)
            {
                case NamedPosition.East:
                    serializer.Serialize(writer, "east");
                    return;
                case NamedPosition.North:
                    serializer.Serialize(writer, "north");
                    return;
                case NamedPosition.South:
                    serializer.Serialize(writer, "south");
                    return;
                case NamedPosition.Top:
                    serializer.Serialize(writer, "top");
                    return;
                case NamedPosition.West:
                    serializer.Serialize(writer, "west");
                    return;
            }
            throw new Exception("Cannot marshal type NamedPosition");
        }

        public static readonly NamedPositionConverter Singleton = new NamedPositionConverter();
    }

    internal class ProjectionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Projection) || t == typeof(Projection?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "orthographic":
                    return Projection.Orthographic;
                case "perspective":
                    return Projection.Perspective;
            }
            throw new Exception("Cannot unmarshal type Projection");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Projection)untypedValue;
            switch (value)
            {
                case Projection.Orthographic:
                    serializer.Serialize(writer, "orthographic");
                    return;
                case Projection.Perspective:
                    serializer.Serialize(writer, "perspective");
                    return;
            }
            throw new Exception("Cannot marshal type Projection");
        }

        public static readonly ProjectionConverter Singleton = new ProjectionConverter();
    }

    internal class ConditionTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ConditionType) || t == typeof(ConditionType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "does not equal":
                    return ConditionType.DoesNotEqual;
                case "equals":
                    return ConditionType.Equals;
            }
            throw new Exception("Cannot unmarshal type ConditionType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ConditionType)untypedValue;
            switch (value)
            {
                case ConditionType.DoesNotEqual:
                    serializer.Serialize(writer, "does not equal");
                    return;
                case ConditionType.Equals:
                    serializer.Serialize(writer, "equals");
                    return;
            }
            throw new Exception("Cannot marshal type ConditionType");
        }

        public static readonly ConditionTypeConverter Singleton = new ConditionTypeConverter();
    }

    internal class HyparLockConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(HyparLock) || t == typeof(HyparLock?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new HyparLock { Bool = boolValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<string[]>(reader);
                    return new HyparLock { StringArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type HyparLock");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (HyparLock)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.StringArray != null)
            {
                serializer.Serialize(writer, value.StringArray);
                return;
            }
            throw new Exception("Cannot marshal type HyparLock");
        }

        public static readonly HyparLockConverter Singleton = new HyparLockConverter();
    }

    internal class HyparShowIfTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(HyparShowIfType) || t == typeof(HyparShowIfType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "all":
                    return HyparShowIfType.All;
                case "any":
                    return HyparShowIfType.Any;
            }
            throw new Exception("Cannot unmarshal type HyparShowIfType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (HyparShowIfType)untypedValue;
            switch (value)
            {
                case HyparShowIfType.All:
                    serializer.Serialize(writer, "all");
                    return;
                case HyparShowIfType.Any:
                    serializer.Serialize(writer, "any");
                    return;
            }
            throw new Exception("Cannot marshal type HyparShowIfType");
        }

        public static readonly HyparShowIfTypeConverter Singleton = new HyparShowIfTypeConverter();
    }

    internal class HyparStyleConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(HyparStyle) || t == typeof(HyparStyle?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "matrix":
                    return HyparStyle.Matrix;
                case "number":
                    return HyparStyle.Number;
                case "row":
                    return HyparStyle.Row;
                case "standard":
                    return HyparStyle.Standard;
            }
            throw new Exception("Cannot unmarshal type HyparStyle");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (HyparStyle)untypedValue;
            switch (value)
            {
                case HyparStyle.Matrix:
                    serializer.Serialize(writer, "matrix");
                    return;
                case HyparStyle.Number:
                    serializer.Serialize(writer, "number");
                    return;
                case HyparStyle.Row:
                    serializer.Serialize(writer, "row");
                    return;
                case HyparStyle.Standard:
                    serializer.Serialize(writer, "standard");
                    return;
            }
            throw new Exception("Cannot marshal type HyparStyle");
        }

        public static readonly HyparStyleConverter Singleton = new HyparStyleConverter();
    }

    internal class AggregatorConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Aggregator) || t == typeof(Aggregator?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Average":
                    return Aggregator.Average;
                case "Count":
                    return Aggregator.Count;
                case "Count Unique":
                    return Aggregator.CountUnique;
                case "Display":
                    return Aggregator.Display;
                case "Display Unique":
                    return Aggregator.DisplayUnique;
                case "Max":
                    return Aggregator.Max;
                case "Min":
                    return Aggregator.Min;
                case "Non-Zero Average":
                    return Aggregator.NonZeroAverage;
                case "None":
                    return Aggregator.None;
                case "Single Value":
                    return Aggregator.SingleValue;
                case "Sum":
                    return Aggregator.Sum;
            }
            throw new Exception("Cannot unmarshal type Aggregator");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Aggregator)untypedValue;
            switch (value)
            {
                case Aggregator.Average:
                    serializer.Serialize(writer, "Average");
                    return;
                case Aggregator.Count:
                    serializer.Serialize(writer, "Count");
                    return;
                case Aggregator.CountUnique:
                    serializer.Serialize(writer, "Count Unique");
                    return;
                case Aggregator.Display:
                    serializer.Serialize(writer, "Display");
                    return;
                case Aggregator.DisplayUnique:
                    serializer.Serialize(writer, "Display Unique");
                    return;
                case Aggregator.Max:
                    serializer.Serialize(writer, "Max");
                    return;
                case Aggregator.Min:
                    serializer.Serialize(writer, "Min");
                    return;
                case Aggregator.NonZeroAverage:
                    serializer.Serialize(writer, "Non-Zero Average");
                    return;
                case Aggregator.None:
                    serializer.Serialize(writer, "None");
                    return;
                case Aggregator.SingleValue:
                    serializer.Serialize(writer, "Single Value");
                    return;
                case Aggregator.Sum:
                    serializer.Serialize(writer, "Sum");
                    return;
            }
            throw new Exception("Cannot marshal type Aggregator");
        }

        public static readonly AggregatorConverter Singleton = new AggregatorConverter();
    }

    internal class DependencyValueConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DependencyValue) || t == typeof(DependencyValue?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<HyparFunctionInputSchemaMetaSchemaElement>(reader);
                    return new DependencyValue { HyparFunctionInputSchemaMetaSchemaElement = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<string[]>(reader);
                    return new DependencyValue { StringArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type DependencyValue");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (DependencyValue)untypedValue;
            if (value.StringArray != null)
            {
                serializer.Serialize(writer, value.StringArray);
                return;
            }
            if (value.HyparFunctionInputSchemaMetaSchemaElement != null)
            {
                serializer.Serialize(writer, value.HyparFunctionInputSchemaMetaSchemaElement);
                return;
            }
            throw new Exception("Cannot marshal type DependencyValue");
        }

        public static readonly DependencyValueConverter Singleton = new DependencyValueConverter();
    }

    internal class ItemsConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Items) || t == typeof(Items?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<HyparFunctionInputSchemaMetaSchemaElement>(reader);
                    return new Items { HyparFunctionInputSchemaMetaSchemaElement = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<HyparFunctionInputSchemaMetaSchemaElement[]>(reader);
                    return new Items { HyparFunctionInputSchemaMetaSchemaElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Items");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Items)untypedValue;
            if (value.HyparFunctionInputSchemaMetaSchemaElementArray != null)
            {
                serializer.Serialize(writer, value.HyparFunctionInputSchemaMetaSchemaElementArray);
                return;
            }
            if (value.HyparFunctionInputSchemaMetaSchemaElement != null)
            {
                serializer.Serialize(writer, value.HyparFunctionInputSchemaMetaSchemaElement);
                return;
            }
            throw new Exception("Cannot marshal type Items");
        }

        public static readonly ItemsConverter Singleton = new ItemsConverter();
    }

    internal class TypeUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TypeUnion) || t == typeof(TypeUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "array":
                            return new TypeUnion { Enum = SimpleTypes.Array };
                        case "boolean":
                            return new TypeUnion { Enum = SimpleTypes.Boolean };
                        case "integer":
                            return new TypeUnion { Enum = SimpleTypes.Integer };
                        case "null":
                            return new TypeUnion { Enum = SimpleTypes.Null };
                        case "number":
                            return new TypeUnion { Enum = SimpleTypes.Number };
                        case "object":
                            return new TypeUnion { Enum = SimpleTypes.Object };
                        case "string":
                            return new TypeUnion { Enum = SimpleTypes.String };
                    }
                    break;
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<SimpleTypes[]>(reader);
                    return new TypeUnion { StringArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type TypeUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (TypeUnion)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case SimpleTypes.Array:
                        serializer.Serialize(writer, "array");
                        return;
                    case SimpleTypes.Boolean:
                        serializer.Serialize(writer, "boolean");
                        return;
                    case SimpleTypes.Integer:
                        serializer.Serialize(writer, "integer");
                        return;
                    case SimpleTypes.Null:
                        serializer.Serialize(writer, "null");
                        return;
                    case SimpleTypes.Number:
                        serializer.Serialize(writer, "number");
                        return;
                    case SimpleTypes.Object:
                        serializer.Serialize(writer, "object");
                        return;
                    case SimpleTypes.String:
                        serializer.Serialize(writer, "string");
                        return;
                }
            }
            if (value.StringArray != null)
            {
                serializer.Serialize(writer, value.StringArray);
                return;
            }
            throw new Exception("Cannot marshal type TypeUnion");
        }

        public static readonly TypeUnionConverter Singleton = new TypeUnionConverter();
    }

    internal class SimpleTypesConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(SimpleTypes) || t == typeof(SimpleTypes?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "array":
                    return SimpleTypes.Array;
                case "boolean":
                    return SimpleTypes.Boolean;
                case "integer":
                    return SimpleTypes.Integer;
                case "null":
                    return SimpleTypes.Null;
                case "number":
                    return SimpleTypes.Number;
                case "object":
                    return SimpleTypes.Object;
                case "string":
                    return SimpleTypes.String;
            }
            throw new Exception("Cannot unmarshal type SimpleTypes");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (SimpleTypes)untypedValue;
            switch (value)
            {
                case SimpleTypes.Array:
                    serializer.Serialize(writer, "array");
                    return;
                case SimpleTypes.Boolean:
                    serializer.Serialize(writer, "boolean");
                    return;
                case SimpleTypes.Integer:
                    serializer.Serialize(writer, "integer");
                    return;
                case SimpleTypes.Null:
                    serializer.Serialize(writer, "null");
                    return;
                case SimpleTypes.Number:
                    serializer.Serialize(writer, "number");
                    return;
                case SimpleTypes.Object:
                    serializer.Serialize(writer, "object");
                    return;
                case SimpleTypes.String:
                    serializer.Serialize(writer, "string");
                    return;
            }
            throw new Exception("Cannot marshal type SimpleTypes");
        }

        public static readonly SimpleTypesConverter Singleton = new SimpleTypesConverter();
    }

    internal class InputSchemaTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(InputSchemaType) || t == typeof(InputSchemaType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "object")
            {
                return InputSchemaType.Object;
            }
            throw new Exception("Cannot unmarshal type InputSchemaType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (InputSchemaType)untypedValue;
            if (value == InputSchemaType.Object)
            {
                serializer.Serialize(writer, "object");
                return;
            }
            throw new Exception("Cannot marshal type InputSchemaType");
        }

        public static readonly InputSchemaTypeConverter Singleton = new InputSchemaTypeConverter();
    }

    internal class InputElementConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(InputElement) || t == typeof(InputElement?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new InputElement { };
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new InputElement { Integer = integerValue };
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new InputElement { Double = doubleValue };
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new InputElement { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new InputElement { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<InputClass>(reader);
                    return new InputElement { InputClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<object[]>(reader);
                    return new InputElement { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type InputElement");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (InputElement)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.InputClass != null)
            {
                serializer.Serialize(writer, value.InputClass);
                return;
            }
            throw new Exception("Cannot marshal type InputElement");
        }

        public static readonly InputElementConverter Singleton = new InputElementConverter();
    }

    internal class ContentTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ContentType) || t == typeof(ContentType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "application/json":
                    return ContentType.ApplicationJson;
                case "text/csv":
                    return ContentType.TextCsv;
                case "text/ifc":
                    return ContentType.TextIfc;
            }
            throw new Exception("Cannot unmarshal type ContentType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ContentType)untypedValue;
            switch (value)
            {
                case ContentType.ApplicationJson:
                    serializer.Serialize(writer, "application/json");
                    return;
                case ContentType.TextCsv:
                    serializer.Serialize(writer, "text/csv");
                    return;
                case ContentType.TextIfc:
                    serializer.Serialize(writer, "text/ifc");
                    return;
            }
            throw new Exception("Cannot marshal type ContentType");
        }

        public static readonly ContentTypeConverter Singleton = new ContentTypeConverter();
    }

    internal class ItemTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ItemType) || t == typeof(ItemType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "range":
                    return ItemType.Range;
                case "string":
                    return ItemType.String;
            }
            throw new Exception("Cannot unmarshal type ItemType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ItemType)untypedValue;
            switch (value)
            {
                case ItemType.Range:
                    serializer.Serialize(writer, "range");
                    return;
                case ItemType.String:
                    serializer.Serialize(writer, "string");
                    return;
            }
            throw new Exception("Cannot marshal type ItemType");
        }

        public static readonly ItemTypeConverter Singleton = new ItemTypeConverter();
    }

    internal class PrimitiveTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PrimitiveType) || t == typeof(PrimitiveType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "polygon":
                    return PrimitiveType.Polygon;
                case "polyline":
                    return PrimitiveType.Polyline;
            }
            throw new Exception("Cannot unmarshal type PrimitiveType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PrimitiveType)untypedValue;
            switch (value)
            {
                case PrimitiveType.Polygon:
                    serializer.Serialize(writer, "polygon");
                    return;
                case PrimitiveType.Polyline:
                    serializer.Serialize(writer, "polyline");
                    return;
            }
            throw new Exception("Cannot marshal type PrimitiveType");
        }

        public static readonly PrimitiveTypeConverter Singleton = new PrimitiveTypeConverter();
    }

    internal class InputTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(InputType) || t == typeof(InputType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "boolean":
                    return InputType.Boolean;
                case "choice":
                    return InputType.Choice;
                case "data":
                    return InputType.Data;
                case "geometry":
                    return InputType.Geometry;
                case "list":
                    return InputType.List;
                case "location":
                    return InputType.Location;
                case "number":
                    return InputType.Number;
                case "range":
                    return InputType.Range;
                case "string":
                    return InputType.String;
            }
            throw new Exception("Cannot unmarshal type InputType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (InputType)untypedValue;
            switch (value)
            {
                case InputType.Boolean:
                    serializer.Serialize(writer, "boolean");
                    return;
                case InputType.Choice:
                    serializer.Serialize(writer, "choice");
                    return;
                case InputType.Data:
                    serializer.Serialize(writer, "data");
                    return;
                case InputType.Geometry:
                    serializer.Serialize(writer, "geometry");
                    return;
                case InputType.List:
                    serializer.Serialize(writer, "list");
                    return;
                case InputType.Location:
                    serializer.Serialize(writer, "location");
                    return;
                case InputType.Number:
                    serializer.Serialize(writer, "number");
                    return;
                case InputType.Range:
                    serializer.Serialize(writer, "range");
                    return;
                case InputType.String:
                    serializer.Serialize(writer, "string");
                    return;
            }
            throw new Exception("Cannot marshal type InputType");
        }

        public static readonly InputTypeConverter Singleton = new InputTypeConverter();
    }

    internal class UnitTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(UnitType) || t == typeof(UnitType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "area":
                    return UnitType.Area;
                case "force":
                    return UnitType.Force;
                case "length":
                    return UnitType.Length;
                case "mass":
                    return UnitType.Mass;
                case "none":
                    return UnitType.None;
                case "plane_angle":
                    return UnitType.PlaneAngle;
                case "pressure":
                    return UnitType.Pressure;
                case "time":
                    return UnitType.Time;
                case "volume":
                    return UnitType.Volume;
            }
            throw new Exception("Cannot unmarshal type UnitType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (UnitType)untypedValue;
            switch (value)
            {
                case UnitType.Area:
                    serializer.Serialize(writer, "area");
                    return;
                case UnitType.Force:
                    serializer.Serialize(writer, "force");
                    return;
                case UnitType.Length:
                    serializer.Serialize(writer, "length");
                    return;
                case UnitType.Mass:
                    serializer.Serialize(writer, "mass");
                    return;
                case UnitType.None:
                    serializer.Serialize(writer, "none");
                    return;
                case UnitType.PlaneAngle:
                    serializer.Serialize(writer, "plane_angle");
                    return;
                case UnitType.Pressure:
                    serializer.Serialize(writer, "pressure");
                    return;
                case UnitType.Time:
                    serializer.Serialize(writer, "time");
                    return;
                case UnitType.Volume:
                    serializer.Serialize(writer, "volume");
                    return;
            }
            throw new Exception("Cannot marshal type UnitType");
        }

        public static readonly UnitTypeConverter Singleton = new UnitTypeConverter();
    }

    internal class LanguageConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Language) || t == typeof(Language?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "C#":
                    return Language.C;
                case "Excel":
                    return Language.Excel;
                case "Grasshopper":
                    return Language.Grasshopper;
                case "Python":
                    return Language.Python;
            }
            throw new Exception("Cannot unmarshal type Language");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Language)untypedValue;
            switch (value)
            {
                case Language.C:
                    serializer.Serialize(writer, "C#");
                    return;
                case Language.Excel:
                    serializer.Serialize(writer, "Excel");
                    return;
                case Language.Grasshopper:
                    serializer.Serialize(writer, "Grasshopper");
                    return;
                case Language.Python:
                    serializer.Serialize(writer, "Python");
                    return;
            }
            throw new Exception("Cannot marshal type Language");
        }

        public static readonly LanguageConverter Singleton = new LanguageConverter();
    }

    internal class OutputTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(OutputType) || t == typeof(OutputType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "number":
                    return OutputType.Number;
                case "string":
                    return OutputType.String;
            }
            throw new Exception("Cannot unmarshal type OutputType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (OutputType)untypedValue;
            switch (value)
            {
                case OutputType.Number:
                    serializer.Serialize(writer, "number");
                    return;
                case OutputType.String:
                    serializer.Serialize(writer, "string");
                    return;
            }
            throw new Exception("Cannot marshal type OutputType");
        }

        public static readonly OutputTypeConverter Singleton = new OutputTypeConverter();
    }
}
